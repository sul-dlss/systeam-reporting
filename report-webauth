#!/usr/bin/env ruby
#
# Generate a list of servers using webauth class.

require 'json'
require 'httparty'
require 'net/smtp'
require 'optparse'
require 'yaml'
require 'active_support/all'
require 'csv'

EMAIL_TO = 'sul-sysadmin-rpts@lists.stanford.edu'.freeze

@puppetdbs = {
#  'v3' => 'http://sulpuppet-db.stanford.edu:8080/v3',
  'v4' => 'http://sulpuppet-db.stanford.edu:8080/pdb/query/v4',
}

#############################################################################
# PuppetDB functions
#############################################################################

def request(endpoint, query = nil, payload = {})
  responses = []

  @puppetdbs.each do |version, path|
    options = { 'query' => query.to_json }
    payload.each do |k, v|
      if version == 'v3'
        options[k.to_s.sub('_', '-')] = v
      else
        options[k.to_s] = v
      end
    end

    response = HTTParty.get("#{path}/#{endpoint}", body: options)
    tmp_rsp = JSON.parse response.body
    tmp_rsp.each do |r|
      responses.push(r)
    end
  end

  responses
end

#############################################################################
# Common functions
#############################################################################

# Given the name of a class, return all hosts that use that class.
def servers_with_class(classname)
  hosts = []
  query = ['and', ['=', 'type', 'Class'], ['=', 'title', classname]]
  response = request('resources', query)
  response.each do |r|
    hostname = r['certname']
    hosts << hostname
  end

  hosts
end

# Given a message, send it out as an email.
def mail_message(content)
  message = ''
  message << "From: Do Not Reply <nobody@stanford.edu>\n"
  message << "To: #{EMAIL_TO}\n"
  message << "Subject: Puppet servers using profile::webserver::vhost::webauth\n"
  message << "\n"
  message << content

  Net::SMTP.start('localhost') do |smtp|
    smtp.send_message message, 'nobody@stanford.edu', EMAIL_TO
  end
end

def hieradata (host)
  project  = ''
  access   = []
  optional = 'off'
  login    = ''
  logout   = ''

  fname = "/Users/jonrober/puppet/hieradata/node/#{host}.eyaml"
  File.readlines(fname).each do |line|
    if line =~ /^\s*project: '(\S+)'/
      project = $~[1]
    elsif line =~ /^\s*webauth_optional: 'on'/
      optional = 'on'
    elsif line =~ /^\s*auth_require: '(.+)'/
      $~[1].split(' ').each do |a|
        access.push(a)
      end
    elsif line =~ /^\s*webauth_login_path: '(\S+)'/
      login = $~[1]
    elsif line =~ /^\s*webauth_logout_path: '(\S+)'/
      logout = $~[1]
    end
  end

  access.uniq!

  [project, access, optional, login, logout]
end

#############################################################################
# Main routine
#############################################################################

# Parse the options, currently --dryrun.
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: puppetdb-mail [options]"
  opts.on('-d', '--dryrun', 'Do not send mail or create tickets') do
    options[:dryrun] = true
  end
end.parse!

webauth = servers_with_class('Profile::Webserver::Vhost::Webauth')
webauth << servers_with_class('S_apache::Webauth')
webauth.flatten!

headers = ['Project', 'Host', 'Access', 'Optional', 'Login', 'Logout']
if (options[:dryrun])
  puts headers.to_csv
  webauth.sort.each do |host|
    project, access, optional, login, logout = hieradata(host)
    puts [project, host, access.sort.join("\n"), optional, login, logout].to_csv
  end
else
  mail_message(webauth.sort.join("\n"))
end
