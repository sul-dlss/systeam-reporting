#!/usr/bin/env ruby
#
# Generate a list of servers using a specific class, for various reporting.

require 'json'
require 'httparty'
require 'net/smtp'
require 'optparse'
require 'yaml'
require 'active_support/all'

EMAIL_TO = 'sul-sysadmin-rpts@lists.stanford.edu'.freeze

@puppetdbs = {
  'v4' => 'http://sulpuppet4-db.stanford.edu:8080/pdb/query/v4',
}

#############################################################################
# PuppetDB functions
#############################################################################

def request(endpoint, query = nil, payload = {})
  responses = []

  @puppetdbs.each do |version, path|
    options = { 'query' => query.to_json }
    payload.each do |k, v|
      if version == 'v3'
        options[k.to_s.sub('_', '-')] = v
      else
        options[k.to_s] = v
      end
    end

    response = HTTParty.get("#{path}/#{endpoint}", body: options)
    tmp_rsp = JSON.parse response.body
    tmp_rsp.each do |r|
      responses.push(r)
    end
  end

  responses
end

#############################################################################
# Common functions
#############################################################################

# Given the name of a class, return all hosts that use that class.
def servers_with_fact(factname)
  servers = {}
  query = ['=', 'name', factname]
  response = request('facts', query)
  response.each do |r|
    hostname = r['certname']
    factname = r['value']
    servers[hostname] = factname
  end

  servers
end

# Given a message, send it out as an email.
def mail_message(subject, content)
  message = ''
  message << "From: Do Not Reply <nobody@stanford.edu>\n"
  message << "To: #{EMAIL_TO}\n"
  message << "Subject: #{subject}\n"
  message << "\n"
  message << content

  Net::SMTP.start('localhost') do |smtp|
    smtp.send_message message, 'nobody@stanford.edu', EMAIL_TO
  end
end

#############################################################################
# Main routine
#############################################################################

# Parse the options, currently --dryrun.
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: report-classes [options]"
  opts.on('-d', '--dryrun', 'Do not send mail') do
    options[:dryrun] = true
  end
  opts.on('-s=SUBJECT', '--subject=SUBJECT', 'Subject for mail') do |s|
    options[:subject] = s
  end
end.parse!

fact_name = ARGV[0]
servers = servers_with_fact(ARGV[0])

output = ''
servers.keys.sort.each { |host|
  output <<  "%-45s %s\n" % [host, servers[host]]
}

# Print out the servers, either in mail or to STDOUT.
if (options[:dryrun])
  servers.keys.sort.each { |host|
    puts output
  }
else
  if options[:subject]
    subject = options[:subject]
  else
    subject = "Report for servers with fact #{fact_name}"
  end
  mail_message(subject, output)
end
