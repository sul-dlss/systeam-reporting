#!/usr/bin/perl
#
# server-status - Get a list of all our VMs and important statuses
#
# Written by Jon Robertson <jonrober@stanford.edu>
# Copyright 2015
#     The Board of Trustees of the Leland Stanford Junior University

#############################################################################
# Modules and declarations
#############################################################################

use 5.010;
use autodie;
use strict;
use warnings;

use JSON;
use LWP::UserAgent;
use Net::DNS::Resolver;

use Getopt::Long::Descriptive;
use IO::Handle;

# Our option descriptions, for both defining options and their usage.
our @OPTIONS = (
    ['help|h',     'print usage (this text) and exit'],
    ['manual|man', 'print perldoc and exit'],
    ['email|e=s',  'send as an email to the given address'],
    ['all-hosts',  'show even systems we normally skip via regex'],
);

my $PUPPETDB_RESOURCES = 'http://sulpuppet-db.stanford.edu:8080/v3/resources';
my $PUPPETDB_QUERY_FMT = 'query=["and", ["=", "type", "%s"], ["=", "title", "%s"]]';
my $PUPPETDB_NODES     = 'http://sulpuppet-db.stanford.edu:8080/v3/nodes';

# A list of regular expressions for hosts that we don't normally want to see
# in our reports.  These should only be shown during quarterly reports for
# doing a full check of all our host statuses.
my @SKIP_HOSTS = ('^sulhp-\d+', '^SUL-', '^fh-c\d+', '^sul-cycl-');

#############################################################################
# Email functions
#############################################################################

# Send off the report.
sub mail_report {
    my ($to, $contents) = @_;

    open (MAIL, '| /usr/sbin/sendmail -t -oi -oem')
        or die "$0: cannot fork sendmail: $!\n";

    print MAIL "To: $to\n";
    print MAIL "From: nobody\@stanford.edu\n";
    print MAIL "Subject: SUL Systeam Servers Report\n";
    print MAIL "\n";
    print MAIL $contents;
    close (MAIL);
}

#############################################################################
# DNS queries
#############################################################################

# Given a list of hosts, check each in DNS to see if they are still active or
# not.  Returns a list of those that are active.
sub check_dns {
    my (@hosts) = @_;

    my @alive = ();
    my $res = Net::DNS::Resolver->new;
    for my $host (@hosts) {
        my $fullhost = $host;
        if ($fullhost !~ m{\.}) {
            $fullhost .= '.stanford.edu';
        }

        my $reply = $res->search($fullhost);
        next unless $reply;

        foreach my $rr ($reply->answer) {
            next unless $rr->type eq 'A';
            push(@alive, $host);
            last;
        }
    }

    return sort(@alive);
}

#############################################################################
# Remote queries
#############################################################################

# Find a list of all virtual machines.  This uses the ezmomi python script to
# do the actual search, then parses the output.
sub find_all_vms {
    my $output = `remctl sulcobbler vm-misc list`;

    my %servers = ();
    for my $line (split(m{[\r\n]+}, $output)) {
        next if $line =~ m{^Name };

        my ($host, $status, $template, $cpus, $mem) = split(m{\s+}, $line);
        $status =~ s{powered}{};
        $servers{$host}{'status'} = $status;
        $servers{$host}{'template'} = $template;
        $servers{$host}{'cpus'} = $cpus;
        $servers{$host}{'memory'} = $mem;
    }

    return %servers;
}

# Find hiera status using a remctl command on the puppet machines.
sub find_hiera_status {
    my $output = `remctl sulpuppet-c hiera-status list`;

    my $json_obj = JSON->new->allow_nonref;
    my $hieradata = $json_obj->decode($output);

    return %{$hieradata};
}

# Find netdb entries using our provisioning script on sulcobbler.
sub find_all_netdb {
    my $output = `remctl sulcobbler netdb list`;

    my @servers = ();
    for my $hostname (split(m{[\r\n]+}, $output)) {
        chomp $hostname;
        push(@servers, $hostname);
    }

    return sort(@servers);
}

# Find all servers that are set up in cobbler on sulcobbler.
sub find_all_cobbler {
    my $output = `remctl sulcobbler cobbler-create system-list`;
    my @servers = ();
    for my $hostname (split(m{[\r\n]+}, $output)) {
        chomp $hostname;
        $hostname =~ s{^\s+}{};
        push(@servers, $hostname);
    }

    return sort(@servers);
}

#############################################################################
# PuppetDB queries
#############################################################################

# Find all hosts currently in puppetdb and return as a list.
sub puppetdb_hosts {

    # Create and make the request to the puppetdb service.
    my $ua = LWP::UserAgent->new;
    $ua->agent('server-status');
    my $req = HTTP::Request->new(GET => $PUPPETDB_NODES);
    my $res = $ua->request($req);

    # Check the outcome of the response
    if (!$res->is_success) {
        die "could not connect to puppetdb: " . $res->status_line . "\n";
    } elsif ($res->content eq '') {
        warn "no records returned when searching for all nodes\n";
        return();
    }

    # Translate the response from JSON and get all the node names.
    my @servers = ();
    my $json_obj = JSON->new->allow_nonref;
    my $nodes = $json_obj->decode($res->content);
    foreach my $node (@{$nodes}) {
        my $hostname = $node->{name};
        $hostname =~ s{\.stanford\.edu$}{};
        push(@servers, $hostname);
    }

    return sort(@servers);
}

# Given a type and title, perform a puppetdb API query for any nodes matching
# those two settings.  Returns a sorted list of node names.
sub puppetdb_query {
    my ($type, $title) = @_;

    # Create and make the request to the puppetdb service.
    my $ua = LWP::UserAgent->new;
    $ua->agent('server-status');
    my $query = sprintf($PUPPETDB_QUERY_FMT, $type, ucfirst($title));
    my $req = HTTP::Request->new(GET => $PUPPETDB_RESOURCES . '?' . $query);
    my $res = $ua->request($req);

    # Check the outcome of the response
    if (!$res->is_success) {
        die "could not connect to puppetdb: " . $res->status_line . "\n";
    } elsif ($res->content eq '') {
        warn "no records returned when searching for $type=$title\n";
        return();
    }

    # Translate the response from JSON and get all the node names.
    my @servers = ();
    my $json_obj = JSON->new->allow_nonref;
    my $nodes = $json_obj->decode($res->content);
    foreach my $node (@{$nodes}) {
        my $hostname = $node->{certname};
        $hostname =~ s{\.stanford\.edu$}{};
        push(@servers, $hostname);
    }

    return sort(@servers);
}

#############################################################################
# Filtering
#############################################################################

# Do a simple check to see if a host is in a list of regular expressions of
# hosts we want to ignore.  This will let us normally skip things such as
# our VMware servers, which we only want to see during quarterly reports.
sub skip_host {
    my ($host) = @_;
    for my $match (@SKIP_HOSTS) {
        return 1 if $host =~ m{$match};
    }
    return 0;
}

#############################################################################
# Main routine
#############################################################################

# Get errors and output in the same order.
STDOUT->autoflush;

# Clean up the path name.
my $fullpath = $0;
$0 =~ s{ ^ .* / }{}xms;

# Parse command-line options.
my ($options, $usage) = describe_options("$0 %o <args>", @OPTIONS);
if ($options->manual) {
    print_stdout("Feeding myself to perldoc, please wait....\n");
    exec 'perldoc', '-t', $fullpath;
} elsif ($options->help) {
    print_stdout($usage->text);
    exit 0;
}

# TODO: Use vmware to tell whether or not a server is a template and skip
#       if so.

my %hiera    = find_hiera_status();
my %vmware   = find_all_vms();
my %netdb    = map { $_ => 1 } find_all_netdb();
my %cobbler  = map { $_ => 1 } find_all_cobbler();
my %puppet   = map { $_ => 1 } puppetdb_hosts();
my %splunk   = map { $_ => 1 } puppetdb_query('Class', 'Splunk');
my %diamond  = map { $_ => 1 } puppetdb_query('Class', 'Diamond');

my %hosts = (%netdb, %puppet, %vmware, %cobbler);
my %alive    = map { $_ => 1 } check_dns(keys %hosts);

my $output;
$output .= sprintf("%-40s %-8s %-6s %-8s %-8s %-8s\n", 'Host', 'Sources',
                   'Status', 'Splunk', 'Diamond', 'Hiera');
for my $host (sort keys %hosts) {
    next if !$options->all_hosts && skip_host($host);
    next if !$options->all_hosts && exists $vmware{$host}
        && $vmware{$host}{'template'} eq 'True';

    my $splunk  = exists $splunk{$host}  ? 'Yes'                    : 'No';
    my $diamond = exists $diamond{$host} ? 'Yes'                    : 'No';
    my $hiera   = exists $hiera{$host}   ? $hiera{$host}            : '-';
    my $status  = exists $vmware{$host}  ? $vmware{$host}{'status'} : '-';

    my @sources = (' ', ' ', ' ', ' ');
    $sources[0] = 'P' if exists $puppet{$host};
    $sources[1] = 'N' if exists $netdb{$host};
    $sources[2] = 'V' if exists $vmware{$host};
    $sources[3] = 'C' if exists $cobbler{$host};
    my $sources = join(' ', @sources);

    # Splunk doesn't need to be on non-prod boxes.
    if ($host =~ m{-(dev|stage)(-\w|\d)?$} || $host =~ m{^dlss-dev-}) {
        $splunk = 'N/A' if $splunk eq 'No';
    }

    $output .= sprintf("%-40s %-8s %-6s %-8s %-8s %-8s\n", $host, $sources,
                       $status, $splunk, $diamond, $hiera);
}

$output .= "\n";
$output .= "Sources: P = Puppet, N = NetDB, V = VMWare, C = Cobbler\n";

if ($options->email) {
    mail_report($options->email, $output);
} else {
    print $output;
}

exit 0;

__END__

##############################################################################
# Documentation
##############################################################################

=head1 NAME

server-status - Get a list of all VMs and their status against a few metrics

=head1 SYNOPSIS

B<server-status> [B<-h>] [B<--manual>]

=head1 DESCRIPTION

B<server-status> currently is a fairly simple script that queries both VMware
and the puppetdb API to find all

=head1 OPTIONS

=over 4

=item B<-h>, B<--help>

Prints a short command summary for the script.

=item B<--manual>, B<--man>

Prints the perldoc information (this document) for the script.

=back

=head1 AUTHORS

Jon Robertson <jonrober@stanford.edu>

=cut
