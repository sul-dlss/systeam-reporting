#!/usr/bin/perl
#
# server-status - Get a list of all our VMs and important statuses
#
# Written by Jon Robertson <jonrober@stanford.edu>
# Copyright 2015
#     The Board of Trustees of the Leland Stanford Junior University

#############################################################################
# Modules and declarations
#############################################################################

use 5.010;
use autodie;
use strict;
use warnings;

use JSON;
use LWP::UserAgent;
use Net::DNS::Resolver;
use YAML;

use Getopt::Long::Descriptive;
use IO::Handle;

# Our option descriptions, for both defining options and their usage.
our @OPTIONS = (
    ['help|h',     'print usage (this text) and exit'],
    ['manual|man', 'print perldoc and exit'],
    ['email|e=s',  'send as an email to the given address'],
    ['all-hosts',  'show even systems we normally skip via regex'],
    ['yaml',       'export results to yaml for other programs to use']
);

my $PUPPETDB_RESOURCES = 'http://sulpuppet-db.stanford.edu:8080/v3/resources';
my $PUPPETDB_QUERY_FMT = 'query=["and", ["=", "type", "%s"], ["=", "title", "%s"]]';
my $PUPPETDB_NODES     = 'http://sulpuppet-db.stanford.edu:8080/v3/nodes';

# A list of regular expressions for hosts that we don't normally want to see
# in our reports.  These should only be shown during quarterly reports for
# doing a full check of all our host statuses.
my @SKIP_HOSTS = ('^sulhp-\d+', '^SUL-', '^fh-c\d+', '^sul-cycl-');

#############################################################################
# Email functions
#############################################################################

# Send off the report.
sub mail_report {
    my ($to, $contents) = @_;

    open (MAIL, '| /usr/sbin/sendmail -t -oi -oem')
        or die "$0: cannot fork sendmail: $!\n";

    print MAIL "To: $to\n";
    print MAIL "From: nobody\@stanford.edu\n";
    print MAIL "Subject: SUL Systeam Servers Report\n";
    print MAIL "\n";
    print MAIL $contents;
    close (MAIL);
}

#############################################################################
# DNS queries
#############################################################################

# Given a list of hosts, check each in DNS to see if they are still active or
# not.  Returns a list of those that are active.
sub check_dns {
    my (@hosts) = @_;

    my @alive = ();
    my $res = Net::DNS::Resolver->new;
    for my $host (@hosts) {
        my $fullhost = $host;
        if ($fullhost !~ m{\.}) {
            $fullhost .= '.stanford.edu';
        }

        my $reply = $res->search($fullhost);
        next unless $reply;

        foreach my $rr ($reply->answer) {
            next unless $rr->type eq 'A';
            push(@alive, $host);
            last;
        }
    }

    return sort(@alive);
}

#############################################################################
# Remote queries
#############################################################################

# Find a list of all virtual machines.  This uses the ezmomi python script to
# do the actual search, then parses the output.
sub find_all_vms {
    my $output = `remctl sulcobbler vm-misc list`;

    my %servers = ();
    for my $line (split(m{[\r\n]+}, $output)) {
        next if $line =~ m{^Name };

        my ($host, $status, $template, $cpus, $mem) = split(m{\s+}, $line);
        $status =~ s{powered}{};
        $servers{$host}{'status'} = $status;
        $servers{$host}{'template'} = $template;
        $servers{$host}{'cpus'} = $cpus;
        $servers{$host}{'memory'} = $mem;
    }

    return %servers;
}

# Find hiera status using a remctl command on the puppet machines.
sub find_hiera_status {
    my $output = `remctl sulpuppet-c hiera-status list`;

    my $json_obj = JSON->new->allow_nonref;
    my $hieradata = $json_obj->decode($output);

    return %{$hieradata};
}

# Find netdb entries using our provisioning script on sulcobbler.
sub find_all_netdb {
    my $output = `remctl sulcobbler netdb list`;

    my @servers = ();
    for my $hostname (split(m{[\r\n]+}, $output)) {
        chomp $hostname;
        push(@servers, $hostname);
    }

    return sort(@servers);
}

# Find all servers that are set up in cobbler on sulcobbler.
sub find_all_cobbler {
    my $output = `remctl sulcobbler cobbler-create system-list`;
    my @servers = ();
    for my $hostname (split(m{[\r\n]+}, $output)) {
        chomp $hostname;
        $hostname =~ s{^\s+}{};
        push(@servers, $hostname);
    }

    return sort(@servers);
}

#############################################################################
# PuppetDB queries
#############################################################################

# Find all hosts currently in puppetdb and return as a list.
sub puppetdb_hosts {

    # Create and make the request to the puppetdb service.
    my $ua = LWP::UserAgent->new;
    $ua->agent('server-status');
    my $req = HTTP::Request->new(GET => $PUPPETDB_NODES);
    my $res = $ua->request($req);

    # Check the outcome of the response
    if (!$res->is_success) {
        die "could not connect to puppetdb: " . $res->status_line . "\n";
    } elsif ($res->content eq '') {
        warn "no records returned when searching for all nodes\n";
        return();
    }

    # Translate the response from JSON and get all the node names.
    my @servers = ();
    my $json_obj = JSON->new->allow_nonref;
    my $nodes = $json_obj->decode($res->content);
    foreach my $node (@{$nodes}) {
        my $hostname = $node->{name};
        $hostname =~ s{\.stanford\.edu$}{};
        push(@servers, $hostname);
    }

    return sort(@servers);
}

# Given a type and title, perform a puppetdb API query for any nodes matching
# those two settings.  Returns a sorted list of node names.
sub puppetdb_query {
    my ($type, $title) = @_;

    # Create and make the request to the puppetdb service.
    my $ua = LWP::UserAgent->new;
    $ua->agent('server-status');
    my $query = sprintf($PUPPETDB_QUERY_FMT, $type, ucfirst($title));
    my $req = HTTP::Request->new(GET => $PUPPETDB_RESOURCES . '?' . $query);
    my $res = $ua->request($req);

    # Check the outcome of the response
    if (!$res->is_success) {
        die "could not connect to puppetdb: " . $res->status_line . "\n";
    } elsif ($res->content eq '') {
        warn "no records returned when searching for $type=$title\n";
        return();
    }

    # Translate the response from JSON and get all the node names.
    my @servers = ();
    my $json_obj = JSON->new->allow_nonref;
    my $nodes = $json_obj->decode($res->content);
    foreach my $node (@{$nodes}) {
        my $hostname = $node->{certname};
        $hostname =~ s{\.stanford\.edu$}{};
        push(@servers, $hostname);
    }

    return sort(@servers);
}

#############################################################################
# Filtering
#############################################################################

# Do a simple check to see if a host is in a list of regular expressions of
# hosts we want to ignore.  This will let us normally skip things such as
# our VMware servers, which we only want to see during quarterly reports.
sub skip_host {
    my ($host) = @_;
    for my $match (@SKIP_HOSTS) {
        return 1 if $host =~ m{$match};
    }
    return 0;
}

#############################################################################
# Report generation
#############################################################################

# Generate our results as a yaml report so that other programs can get this
# information.
sub yaml_report {
    my ($options) = @_;

    my %hosts;
    my %vms = find_all_vms;
    for my $host (keys %vms) {
        $hosts{$host}{'vmware'} = $vms{$host};
    }
    for my $host (find_all_netdb) {
        $hosts{$host}{'netdb'} = 1;
    }
    for my $host (find_all_cobbler) {
        $hosts{$host}{'cobbler'} = 1;
    }
    for my $host (puppetdb_hosts) {
        $hosts{$host}{'puppetdb'} = 1;
    }
    for my $host (check_dns(keys %hosts)) {
        $hosts{$host}{'alive'} = 1;
    }

    # Clean up any blacklisted hosts.  Easier to do this after the fact than
    # do this in every host check.
    unless ($options->all_hosts) {
        for my $host (keys %hosts) {
            delete $hosts{$host}
                if skip_host($host) || $vms{$host}{'template'} eq 'True';
        }
    }

    print Dump(\%hosts);
}

# Generate the results as a human-readable report, either to stdout or as an
# email.
sub human_report {
    my ($options) = @_;

    my %hiera    = find_hiera_status();
    my %vmware   = find_all_vms();
    my %netdb    = map { $_ => 1 } find_all_netdb();
    my %cobbler  = map { $_ => 1 } find_all_cobbler();
    my %puppet   = map { $_ => 1 } puppetdb_hosts();
    my %splunk   = map { $_ => 1 } puppetdb_query('Class', 'Splunk');
    my %diamond  = map { $_ => 1 } puppetdb_query('Class', 'Diamond');

    my %hosts = (%netdb, %puppet, %vmware, %cobbler);
    my %alive    = map { $_ => 1 } check_dns(keys %hosts);

    my $output;
    $output .= sprintf("%-40s %-8s %-6s %-8s %-8s %-8s\n", 'Host', 'Sources',
                       'Status', 'Splunk', 'Diamond', 'Hiera');
    for my $host (sort keys %hosts) {
        next if !$options->all_hosts && skip_host($host);
        next if !$options->all_hosts && exists $vmware{$host}
            && $vmware{$host}{'template'} eq 'True';

        my $splunk  = exists $splunk{$host}  ? 'Yes'                    : 'No';
        my $diamond = exists $diamond{$host} ? 'Yes'                    : 'No';
        my $hiera   = exists $hiera{$host}   ? $hiera{$host}            : '-';
        my $status  = exists $vmware{$host}  ? $vmware{$host}{'status'} : '-';

        my @sources = (' ', ' ', ' ', ' ');
        $sources[0] = 'P' if exists $puppet{$host};
        $sources[1] = 'N' if exists $netdb{$host};
        $sources[2] = 'V' if exists $vmware{$host};
        $sources[3] = 'C' if exists $cobbler{$host};
        my $sources = join(' ', @sources);

        # Splunk doesn't need to be on non-prod boxes.
        if ($host =~ m{-(dev|stage)(-\w|\d)?$} || $host =~ m{^dlss-dev-}) {
            $splunk = 'N/A' if $splunk eq 'No';
        }

        $output .= sprintf("%-40s %-8s %-6s %-8s %-8s %-8s\n", $host, $sources,
                           $status, $splunk, $diamond, $hiera);
    }

    $output .= "\n";
    $output .= "Sources: P = Puppet, N = NetDB, V = VMWare, C = Cobbler\n";

    if ($options->email) {
        mail_report($options->email, $output);
    } else {
        print $output;
    }
}

#############################################################################
# Main routine
#############################################################################

# Get errors and output in the same order.
STDOUT->autoflush;

# Clean up the path name.
my $fullpath = $0;
$0 =~ s{ ^ .* / }{}xms;

# Parse command-line options.
my ($options, $usage) = describe_options("$0 %o <args>", @OPTIONS);
if ($options->manual) {
    print_stdout("Feeding myself to perldoc, please wait....\n");
    exec 'perldoc', '-t', $fullpath;
} elsif ($options->help) {
    print_stdout($usage->text);
    exit 0;
}

if ($options->yaml) {
    yaml_report($options);
} else {
    human_report($options);
}

exit 0;

__END__

##############################################################################
# Documentation
##############################################################################

=head1 NAME

server-status - Report on all of our servers from various sources of truth

=head1 SYNOPSIS

B<server-status> [B<-h>] [B<--manual>]

=head1 DESCRIPTION

B<server-status> checks our various sources of system information (puppet,
vmware, netdb, cobbler) and builds a report based on those facts.  It has
options to either make a human-readable report with some additional
information, or to print out just that information as a yaml file.  The yaml
file doesn't contain as much information, as it's meant to be parsed by
something that will do further data massaging itself, and so we only want the
base server data in that case.

The reports normally bury some information around servers that are blacklisted
by regex, or are templates in vmware.  This is to keep the normal reports more
manageable, while leaving the ability to do a full report less regularly to
do a complete vetting of our server statuses.

=head1 OPTIONS

=over 4

=item B<-h>, B<--help>

Prints a short command summary for the script.

=item B<--manual>, B<--man>

Prints the perldoc information (this document) for the script.

=item B<--yaml>

Prints the report as a yaml string.

=item B<--email=<address>>

Send the human-readable report to an email address.  Normally called by cron.

=item B<--all-hosts>

Report on the hosts we normally blacklist for being in a regex list, or for
being vmware templates.

=back

=head1 AUTHORS

Jon Robertson <jonrober@stanford.edu>

=cut
