#!/usr/bin/env ruby
#
# Use the already created puppet node state yaml file to send out a mailing
# about each server failed, quiet, or tangled.

require 'github_create_issues'
require 'net/smtp'
require 'yaml'

require 'json'
require 'uri'
require 'net/http'

EMAIL_TO = 'sul-sysadmin-rpts@lists.stanford.edu'.freeze
PUPPET_STATE = '/var/lib/systems-dashboard/puppetstate.yaml'

@SYSADMINS = %w(jonrober ssklar rsmith11 efahy azanella jmorley kamchan)
#@opsgenie_apikey = '38c9f49f-b566-44e9-a0dc-0090d5cb3d24'
@opsgenie_apikey = File.open('/etc/misc/opsgenie.api').read

# Data for github issue creation.
repo  = 'sul-dlss/operations-tasks'
label = 'puppet-notreporting'
token = File.open('/etc/github-issues/oauth-token', 'rb').read
desc = 'Please check to make sure that puppet is running, enabled, and against a good branch.'

#############################################################################
# Opsgenie functions
#############################################################################

# Perform a request against opsgenie and return the JSON response.
def opsgenie_fetch_json(url, params, req_type)
  uri = URI(url)
  https = Net::HTTP.new(uri.host, uri.port)
  https.use_ssl = true
  header = {
    "Content-Type" =>"application/json",
    "Authorization" => "GenieKey #{@opsgenie_apikey}"
  }
  begin
    if req_type=='post'
      res = https.post(uri.path, params, initheader = header)
    else
      uri.query = params.to_json
      res = https.get(uri.path, initheader = header)
    end
    if res.is_a?(Net::HTTPSuccess)
      return JSON.parse(res.body)
    else
      puts res
      return false
    end
  rescue => e
    return false
  end
end

# Request the on-call responder from OpsGenie and return it.
def on_call
  url = "https://api.opsgenie.com/v2/schedules/on-calls"
  params = nil
  response =  opsgenie_fetch_json(url, params, 'get')

  responder = ''
  response['data'].each do |r|
    next if r['_parent']['name'] != 'ops_team_schedule'
    responder = r['onCallParticipants'][0]['name'].gsub(/@stanford\.edu$/, '')
    break
  end

  responder
end

#############################################################################
# Support functions
#############################################################################

def server_assignee(server, environment)
  if (server =~ /^dlss-(dev|win)-(\S+)\.stanford\.edu$/)
    assignee = Regexp.last_match[2]
    return assignee if @SYSADMINS.include?(assignee)
  end

  assignee = @default_asignee
  @SYSADMINS.each do |s|
    next unless environment =~ /^#{s}/
    assignee = s
    break
  end

  assignee
end

#############################################################################
# Main routine
#############################################################################

@default_asignee = on_call

quiet = {}
tangled = []
failed = []
report = YAML.load_file(PUPPET_STATE)
report.keys.each do |server|
  failed.push(server) if report[server].key?('failed')
  tangled.push(server) if report[server].key?('tangled')

  next unless report[server].key?('too_quiet')
  quiet[server] = report[server]['too_quiet']
end

message = ''
message << "From: Do Not Reply <nobody@stanford.edu>\n"
message << "To: #{EMAIL_TO}\n"
message << "Subject: Puppet servers currently having problems\n"
message << "\n"

message << "Servers with failed puppet runs\n"
message << "-------------------------------\n"
failed.sort.each do |server|
  message << server + "\n"
end
message << "\n"

message << "Servers without any puppet runs for over 24 hours\n"
message << "-------------------------------------------------\n"
quiet.keys.sort.each do |server|
  message << format("%-45s %s\n", server, quiet[server])
end

Net::SMTP.start('localhost') do |smtp|
  smtp.send_message message, 'nobody@stanford.edu', EMAIL_TO
end

exit

issues = {}
quiet.keys.each do |server|
  assignee = server_assignee(server, report[server]['environment'])
  issues[assignee] = [] unless issues.key?(assignee)
  issues[assignee].push("#{server} has not run puppet in over 24 hours")
end
failed.each do |server|
  assignee = server_assignee(server, report[server]['environment'])
  issues[assignee] = [] unless issues.key?(assignee)
  issues[assignee].push("#{server}'s puppet runs are failing")
end

# Now create each of these as a github issue.
issues.each_key do |assignee|
  i = issues[assignee]
  GithubCreateIssues.add_github_issues(token, repo, label, i, desc, assignee)
end
